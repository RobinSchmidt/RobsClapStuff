Make one .clap with several plugins

-Gain/Utility: StereoGain (-40..+40), Pan (-1..+1), Pos (-1..+1), MidSide (100/0..100/100..0/100), 
 Mono (switch), PanLaw, PosLaw ...check difference between pan and balance

-Add waveshaper shapes: asinh, x / (1 + |x|), x / sqrt(1 + x*x), x / (1 + x^2), sin, cbrt

-TestTones: Tune, Type (Sine, Saw (Naive), Saw (Clean), Noise, Impulse), Gain. Should respond to 
 midi, i.e. be of the instrument category


-Use CMake for the build system. Maybe try a .sln to cmake converter like this:
 https://cmakeconverter.readthedocs.io/en/latest/use.html
-For doing it manually, see:
 https://cmake.org/cmake/help/book/mastering-cmake/chapter/Converting%20Existing%20Systems%20To%20CMake.html
-For managing CMake build-systems directly in Visual Studio, see:
 https://learn.microsoft.com/en-us/cpp/build/cmake-projects-in-visual-studio?view=msvc-170

Add the following stuff to Utilities.h/cpp:
-assertions that trigger debug breaks - then replace all occurrences of "assert" with this
-memory leak checks
-amp2db, db2amp, pitch2freq, freq2pitch, lin2lin, lin2exp, ...
-string conversion functions for the parameters




-[DONE] Currently the plugin-validator  has one failing test:

   -param-conversions: Asserts that value to string and string to value conversions are supported 
    for ether all or none of the plugin's parameters, and that conversions between values and 
    strings roundtrip consistently. 
    FAILED: Converting 3.0 to a string, back to a value, and then back to a string again for 
    parameter 0 ('Shape') results in 'Erf' -> 0.0 -> 'Clip', which is not consistent.

 Apparently, we need to override paramsTextToValue() to convert back from stings like "Clip", 
 "Tanh", ... to the corresponding numeric value. I think, one good way to do it would be to use a
 std::vector<std::string> shapes; and in ClapWaveShaper::shapeToString() just return 
 shape[shapeIndex]. But that requires the shapes to be stored in the correct order, i.e. in the same
 order as they appear in the enum. But maybe we should implement some sort of index-to-id and back 
 mapper that can then be used for the parameter list as well. That would also solve the problem of
 having to keep the parameter list in the same order from version to version





-Try to use a syntax for the features field like:
 
   .features = (const char *[]) { CLAP_PLUGIN_FEATURE_UTILITY, 
                                  CLAP_PLUGIN_FEATURE_MIXING, NULL },
 
 like it was originally in the nakst example (on which this code is based). But with this 
 syntax, it doesn't compile in Visual Studio 2019. Figure out why. It would be cleaner to have 
 everything in one place and not litter the class declaration with the features array. It's 
 also less error prone because in the code above, we must manually make sure that the "4" in 
 features[4] matches the number of initializers in the list. See:
 https://stackoverflow.com/questions/33270731/error-c4576-in-vs2015-enterprise
 https://github.com/swig/swig/issues/1851
 https://en.cppreference.com/w/c/language/struct_initialization
 ...just removing "(const char *[])" gives a "too many initializers" error.

-Figure out if in the constructors ClapGain(), ClapWaveShaper(), etc one of these checks could make
 sense:
   assert(*desc ==  pluginDescriptor);
   assert( desc == &pluginDescriptor);
 The former would just assert that the content of the descriptor matches while the second 
 actually asserts that a pointer to our own static member is passed, i.e. the second check 
 would be stronger. 

-Check, if we need the CLAP_PARAM_REQUIRES_PROCESS flag for the parameters. I don't thinks so, 
 though - but figure out and document under which circumstances this will be needed. The clap doc 
 says that when this flag is set, the parameter events will be passed via process. Without the 
 flag, that seem not to be ensured - they may be passed via flush... - although Bitwig seems to do
 it via process anyway. Or does it? Check in the debugger! The plugin works even without the flag.
 But maybe that's only so in Bitwig? Figure out!

-A way to reduce the boilerplate even more would be to let the ClapPluginParameter class have two
 function pointers for the conversion to string and for a callback that can be called whenever the
 value changes. That would require making the value private and provide a setValue function that
 sets the value and then calls the callback. Then, instead of overriding setParameter and
 paramsValueToText, we would just assign these two additional members in the constructor. But for 
 this callback mechanism to really reduce boilerplate, we assume that appropriate callback target
 functions already exist anyway - if they don't, they would have to written which is again more 
 boilerplate. However, when using classes from my rapt/rosic DSP libraries, these functions do 
 indeed already exist (like setCutoff, setResonance, etc.). For my own use cases, that might be 
 fine but in order to be more generally useful, that approach might be a bit too opinionated.

-Maybe it's more convenient to apply DC before the drive? With quite high drive, modulating DC
 is like PWM. But the "good" range for DC depends on the amount of drive, if DC is applied 
 after the drive (higher drive allowe for a higher DC range without making the signal disappear, 
 i.e. buried in the clipped DC). That is not so nice. It would be better, if the good range for DC
 would be independent of drive. -> Experiment! But this here is just a demo anyway.

-Rename files to ExampleClapPlugins.h/cpp or DemoClapPlugins and add some more plugins.

-Write a signal generator plugin to demonstrate how to respond to midi events. It should produce
 a sinewave with the note-frequency of the most recently received midi note (as long as it is 
 held). Maybe it could do some other waveforms or other signals as well (e.g. impulses, 
 noise, etc.). Should not be too fancy DSP-wise, though (e.g. have anti-aliasing etc.). This is
 just a demo, so let's keep it as simple as possible.



In the constructor of ClapWaveShaper, instead of:

  addParameter(kShape, "Shape",   0.0, numShapes-1, 0.0, choice     );   // Clip, Tanh, etc.
  addParameter(kDrive, "Drive", -20.0, +60.0,       0.0, automatable);   // In dB
  addParameter(kDC,    "DC",    -10.0, +10.0,       0.0, automatable);   // As raw offset
  addParameter(kGain,  "Gain",  -60.0, +20.0,       0.0, automatable);   // In dB

I want to be able to write:

  addChoiceParameter(kShape, "Shape");     // Clip, Tanh, etc.
  addChoiceOption(kShape, kClip, "Clip");
  addChoiceOption(kShape, kTanh, "Tanh");

  addFloatParameter(kDrive, "Drive", -20.0, +60.0, 0.0, dbToString2);   // In dB


Or maybe:

  using Opt = ChoiceOption;
  addChoiceParameter(kShape, "Shape", { Opt(kClip, "Clip"), Opt(kTanh, "Tanh") } ); 

Or just:

  addChoiceParameter(kShape, "Shape", { { kClip, "Clip" }, { kTanh, "Tanh"} }, kClip ); 



There is potential for optimization in the waveshaper: 
-The branching could be done per block rather than per sample
-We could also do way with the branching completely by using a function pointer to a waveshaping
 function.

-Make a plugin that uses parameters that need some nonlinear mapping function like lin-to-exp for
 a frequency. Maybe we should use a normalized 0..1 range for host/plugin communication just like 
 with VST. See how this example synth handles the "Cutoff" parameter:
 https://github.com/free-audio/clap-saw-demo-imgui/blob/main/src/clap-saw-demo.cpp
 it gives the host the range of 1...127 in ClapSawDemo::paramsInfo and does the lin-to-exp mapping 
 in ClapSawDemo::paramsValueToText

-Maybe design the framework in a way that allows to mix and match required functionality. Maybe the 
 functionalities like parameter/state-handling, midi-handling, gui-handling, etc. should all be 
 implemented as mix-in classes and derived classes can derive from multiple such classes without 
 using the (messy, evil, to-be-avoided-at-all-costs) virtual inheritance. I think, the mix-in 
 classes should *not* be subclasses of the basic ClapPlugin class. Maybe then we could do things 
 like:  
 ClapGain : public ClapPlugin, public ClapWithParameters, public ClapWithStereoInOut {...}
 ClapToneGenerator : public ClapPlugin, public ClapWithParameters, public ClapWithStereoInOut, 
                     public ClapWithMidi {...}
 see: https://en.wikipedia.org/wiki/Mixin

-Figure out best practices for:
 -Handling nonlinear parameter mapping functions. The clap-saw-example uses 1..127 for an 
  exponentially mapped filter cutoff. I guess, I'd use 0..1 by default like in VST.
 -Handling parameter ids - some examples use "random" numbers and std::unordered_map. I use a 
  permutation of the indices.
 -How to sync GUI and audio thread (lock-free queues?). I currently don't have a GUI. Check the
  clap-saw-demo. But maybe it could also be possible to send a message from the GUI to the host that
  the host should send a parameter-change event to the audio engine? Check out the API for issuing
  requests from the plugin to the host. If that is possible, it would make writing plugins much 
  easier, I think. 
 -How to handle out-of-range values for the parameters. Should the plugin sanitize (clip) them? That 
  would add to the CPU load of the plugin just to work around a bug in the host.
 -Naming ports. Should there be spaces in the names or not, etc.
 -Giving ids to ports. Should we start counting from 0 or 1?
 -How is latency handled? The documentation of clap_plugin.activate says that after activation, the
  latency must remain constant. But when I change a "BlockSize" or "LookAhead" parameter in some 
  plugin, the latency will change. How am I supposed to deal with that situation? Can I request a
  de/re-activation from the host? ...YES! In host.h, the clap_host struct has a request_restart 
  field (of type "function-pointer").